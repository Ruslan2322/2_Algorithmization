package Lesson_02_Sorting;
import java.util.Arrays;

// Сортировка вставками. Дана последовательность чисел  a1,a2,...,an . Требуется переставить числа в порядке
// возрастания.  Делается  это  следующим  образом.  Пусть  a1,a2,...,ai   -  упорядоченная  последовательность,  т.  е.
// a1 <= a2 <=... <=an
// Берется  следующее  число  ai+1   и  вставляется  в  последовательность  так,  чтобы  новая
// последовательность была тоже возрастающей. Процесс производится до тех пор, пока все элементы от i +1 до n
// не будут перебраны. Примечание. Место помещения очередного элемента в отсортированную часть производить
// с помощью двоичного поиска. Двоичный поиск оформить в виде отдельной функции.

public class Ex_5 {

    public static void main(String[] args) {
        int[] arr = new int[200];
        for (int i = 0; i < arr.length; i++) {
            arr[i] = (int) (Math.random() * 100);
        }
        System.out.println(Arrays.toString(arr));
        for (int i = 0; i < arr.length; i++) { // проходим по всем элементам массива.
            int insertIndex = Search(arr, i); // функция бинарного поиска
            int temp = arr[i];
            for (int j = i; j > insertIndex; j--) {//смещение элементов при необходимости вправо.
                arr[j] = arr[j - 1];
            }
            arr[insertIndex] = temp;
        }
        System.out.println(Arrays.toString(arr));

    }

    private static int Search(int[] array, int i) {
        int low = 0; //нижняя граница для поиска
        int key = array[i]; // значение, которое будем сравнивать
        int hight = i; // верхняя граница поиска
        while (low < hight) // условие, искомый элемент не находится по середине отрезка.
        {
            int middle = (hight + low) / 2; // поиск середины отрезка
            if (array[middle] > key) // Сравнение элемента в найденной серидине с искомым элементом, если искомый элемент меньше элемента в середине
                // смещаемся влевой для этого верхней границе массива присваиваем индекс найденного среднего элемента hight = middle,
                // в противном случае смещаемся вправо и присваиваем уже нижней границе массива индекс найденного среднего элемента
                // low = middle + 1 - так как при расчете middle у нас округление в меньшую сторону.
                hight = middle;
            else
                low = middle + 1;
        }
        return low;
    }
}